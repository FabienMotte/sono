'use strict';

/*function Echo(context, delayTime, gainValue) {
    var delay = context.createDelay();
    var gain = context.createGain();

    gain.gain.value = gainValue || 0.5;
    if(delayTime !== undefined) { delay.delayTime.value = delayTime; }


    var connect = function(node) {
        disconnect();
        delay.connect(gain);
        gain.connect(delay);
        delay.connect(node);
    };

    var disconnect = function() {
        delay.disconnect();
        gain.disconnect();
    };

    // public methods
    var exports = {
        node: delay,
        // map native methods of EchoNode

        // map native methods of AudioNode
        connect: connect,
        disconnect: disconnect
    };

    // map native properties of EchoNode
    Object.defineProperties(exports, {
        'delayTime': {
            get: function() { return delay.delayTime.value; },
            set: function(value) { delay.delayTime.value = value; }
        },
        'gainValue': {
            get: function() { return gain.gain.value; },
            set: function(value) { gain.gain.value = value; }
        }
    });

    return Object.freeze(exports);
}*/

/*
 * This way is more concise but requires 'connected' to be called in node manager
 */

function Echo(context, delayTime, gainValue) {
    var delay = context.createDelay();
    var gain = context.createGain();

    gain.gain.value = gainValue || 0.5;
    if(delayTime !== undefined) { delay.delayTime.value = delayTime; }

    delay._connected = function() {
        delay.connect(gain);
        gain.connect(delay);
    };

    delay.update = function(delayTime, gainValue) {
        if(delayTime !== undefined) {
            this.delayTime.value = delayTime;
        }
        if(gainValue !== undefined) {
            gain.gain.value = gainValue;
        }
    };

    return delay;
}

/*
 * Exports
 */

if (typeof module === 'object' && module.exports) {
    module.exports = Echo;
}
